use std::{fs::File, io::BufReader};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use bridge_core::{btc::BlockHeader, config::N, incremental_merkle::IncrementalMerkleTree};
use bridge_methods::{GUEST_ELF, GUEST_ID};
use host::core_tx_utils::from_hex_to_tx;
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use serde_json::Value;

#[allow(non_snake_case)]
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BlockInfoExtras {
    reward: u128,
    coinbaseRaw: String,
    orphans: Vec<String>,
    medianFee: f64,
    feeRange: Vec<f64>,
    coinbaseAddress: String,
    header: String,
    // ...
    // add the fields you want
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BlockInfo {
    id: String,
    height: usize,
    version: usize,
    timestamp: u128,
    bits: u128,
    nonce: u128,
    difficulty: f64,
    merkle_root: String,
    tx_count: usize,
    size: u128,
    weight: u128,
    previousblockhash: String,
    mediantime: u128,
    stale: bool,
    extras: BlockInfoExtras,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RpcResult {
    bestblockhash: String,
    chainwork: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RpcInfo {
    result: RpcResult,
}

pub fn json_to_obj<T: DeserializeOwned>(file_path: &str) -> T {
    let file = File::open(file_path).expect("error");
    let reader = BufReader::new(file);
    let a: T = serde_json::from_reader(reader).expect("error");
    return a;
}

fn main() {
    env_logger::init();
    let mut env = ExecutorEnv::builder();
    let input = "020000000001025c290bc400f9e1c3f739f8e57ab60355d5a9ac33e9d2c24145b3565aee6bbce00000000000fdffffffa49a9fe38ffe5f5bda8289098e60572caa758c7795983b0008b5e99f01f446de0000000000fdffffff0300e1f50500000000225120df6f4ee3a0a625db6fa6a88176656541f4a63591f8b7174f7054cc52afbeaec800e1f505000000002251208c61eec2e14c785da78dd8ab98797996f866a6aac8c8d2389d77f38c3f4feff122020000000000002251208c61eec2e14c785da78dd8ab98797996f866a6aac8c8d2389d77f38c3f4feff101405de61774dc0275f491eb46561bc1b36148ef30467bf43f2b33796991d61a29a3a4b7e2047712e73fe983806f0d636b64c8a6202490daff202bca521a0faa70ae0140f80f92541832d6d8908df9a57d994b90ee74129c8943a17109da88d49cd1531314d051c8082be3b79d3281edde719ab2fab34fa3dfbe3ad60e5a2ab8a306d43100000000";
    let tx = from_hex_to_tx::<2, 3>(input);




    env.write(&tx).unwrap();

    let env_build = env.build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env_build, GUEST_ELF).unwrap();

    let (txid,): ([u8; 32],) = receipt.journal.decode().unwrap();
    println!("Output: {:?}", hex::encode(txid));
}

fn main2() {
    env_logger::init();

    let deposit_merkle_tree = IncrementalMerkleTree::initial();
    let withdrawal_merkle_tree = IncrementalMerkleTree::initial();
    let bridge_funds_merkle_tree = IncrementalMerkleTree::initial();

    let block_info_list: Vec<BlockInfo> = json_to_obj::<Value>("./circuits/host/data/block.json")
        .as_array()
        .unwrap()
        .iter()
        .map(|block_info_value| {
            serde_json::from_value::<BlockInfo>(block_info_value.clone()).unwrap()
        })
        .collect();

    let rpc_info_list: Vec<RpcInfo> = json_to_obj::<Value>("./circuits/host/data/rpc.json")
        .as_array()
        .unwrap()
        .iter()
        .map(|rpc_info_value| serde_json::from_value::<RpcInfo>(rpc_info_value.clone()).unwrap())
        .collect();

    // assert_eq!(rpc_info_list.len() - block_info_list.len(), 1);

    let first_chain_work: [u8; 32] = hex::decode(rpc_info_list[0].result.chainwork.clone())
        .unwrap()
        .try_into()
        .unwrap();

    let initial_block_hash: [u8; 32] = hex::decode(block_info_list[0].previousblockhash.clone())
        .unwrap()
        .try_into()
        .unwrap();

    let mut env = ExecutorEnv::builder();

    env.write(&deposit_merkle_tree.index).unwrap();
    env.write(&withdrawal_merkle_tree.index).unwrap();
    env.write(&initial_block_hash).unwrap();
    env.write(&first_chain_work).unwrap();
    env.write(&bridge_funds_merkle_tree.root).unwrap();

    env.write(&deposit_merkle_tree).unwrap();
    env.write(&withdrawal_merkle_tree).unwrap();
    env.write(&bridge_funds_merkle_tree).unwrap();

    let withdrawals: Vec<[u8; 32]> = Vec::new();
    let num_withdrawals = withdrawals.len() as u32;
    env.write(&num_withdrawals).unwrap();  // num_withdrawals

    // let deposits = [[7_u8; 32], [5_u8; 32], [3_u8; 32]];
    let deposits: [[u8; 32]; 0] = [];
    let mut host_bridge_funds_merkle_tree = bridge_funds_merkle_tree.clone();
    let num_deposits = deposits.len() as u32;
    env.write(&num_deposits).unwrap();
    for d in deposits {
        env.write(&d).unwrap();
        host_bridge_funds_merkle_tree.add(d);
    }


    for i in 0..N as usize {
        let block_header: [u8; 80] = hex::decode(block_info_list[i].extras.header.clone())
            .unwrap()
            .try_into()
            .unwrap();
        let block_header = BlockHeader::from_slice(&block_header);
        env.write(&block_header).unwrap();

        env.write(&0).unwrap();  // number of withdrawals
        env.write(&0).unwrap();  // number of moved funds
    }

    for i in 0 ..num_withdrawals-num_deposits {
        env.write(&withdrawals[(num_withdrawals - num_deposits + i) as usize]).unwrap();
    }

    let env_build = env.build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env_build, GUEST_ELF).unwrap();

    let (mut start_deposit_index, start_withdrawal_index, initial_block_hash, initial_work, initial_bridge_funds_merkle_root, deposit_last_index, withdrawal_last_index, mut output_block_hash, light_client_pow, bridge_funds_merkle_root, mut last_finalized_block_hash, last_chain_work): (u32, u32, [u8; 32], [u8; 32], [u8; 32], u32, u32, [u8; 32], [u8; 32], [u8; 32], [u8; 32], [u8; 32]) =
        receipt.journal.decode().unwrap();

    output_block_hash.reverse();
    last_finalized_block_hash.reverse();

    println!("Output: {}", hex::encode(output_block_hash));
    println!("Output: {}", hex::encode(last_finalized_block_hash));
    println!("Chain Work: {}", hex::encode(last_chain_work));

    assert_eq!(
        hex::encode(last_chain_work),
        rpc_info_list[rpc_info_list.len() - 1].result.chainwork
    );

    assert_eq!(
        hex::encode(last_finalized_block_hash),
        rpc_info_list[rpc_info_list.len() - 1].result.bestblockhash
    );

    assert_eq!(deposit_last_index, start_deposit_index + num_deposits);

    assert_eq!(bridge_funds_merkle_root, host_bridge_funds_merkle_tree.root);

    // Optional: Verify receipt to confirm that recipients will also be able to
    // verify your receipt
    receipt.verify(GUEST_ID).unwrap();
}
