use std::{fs::File, io::BufReader};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use bridge_core::btc::{calculate_double_sha256, BlockHeader, validate_threshold_and_add_work};
use bridge_methods::{GUEST_ELF, GUEST_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use serde::{Serialize, Deserialize, de::DeserializeOwned};
use serde_json::Value;

#[allow(non_snake_case)]
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BlockInfoExtras {
    reward: u128,
    coinbaseRaw: String,
    orphans: Vec<String>,
    medianFee: f64,
    feeRange: Vec<f64>,
    coinbaseAddress: String,
    header: String,
    // ...
    // add the fields you want
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct BlockInfo {
    id: String,
    height: usize,
    version: usize,
    timestamp: u128,
    bits: u128,
    nonce: u128,
    difficulty: f64,
    merkle_root: String,
    tx_count: usize,
    size: u128,
    weight: u128,
    previousblockhash: String,
    mediantime: u128,
    stale: bool,
    extras: BlockInfoExtras
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RpcResult {
    bestblockhash: String,
    chainwork: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct RpcInfo {
    result: RpcResult
}

pub fn json_to_obj<T: DeserializeOwned>(file_path: &str) -> T {
    let file = File::open(file_path).expect("error");
    let reader = BufReader::new(file);
    let a: T = serde_json::from_reader(reader).expect("error");
    return a;
}

fn main() {
    env_logger::init();

    let block_info_list: Vec<BlockInfo> = json_to_obj::<Value>("./host/data/block.json").as_array().unwrap().iter().map(|block_info_value| serde_json::from_value::<BlockInfo>(block_info_value.clone()).unwrap()).collect();

    let rpc_info_list: Vec<RpcInfo> = json_to_obj::<Value>("./host/data/rpc.json").as_array().unwrap().iter().map(|rpc_info_value| serde_json::from_value::<RpcInfo>(rpc_info_value.clone()).unwrap()).collect();

    assert_eq!(rpc_info_list.len() - block_info_list.len(), 1);

    let n = rpc_info_list.len();

    for i in 1..n {
        let block_info = &block_info_list[i - 1];
        let work1 = &rpc_info_list[i - 1].result.chainwork;
        let work2 = &rpc_info_list[i].result.chainwork;

        let input: [u8; 80] = hex::decode(block_info.extras.header.clone())
            .unwrap()
            .try_into()
            .unwrap();

        let block_header = BlockHeader::from_slice(&input);

        println!("Input: {}", hex::encode(input));

        println!(
            "Double SHA256: {}",
            hex::encode(calculate_double_sha256(&input))
        );

        let chain_work1: [u8; 32] = hex::decode(work1).unwrap().try_into().unwrap();
        let _chain_work2: [u8; 32] = hex::decode(work2).unwrap().try_into().unwrap();

        let env = ExecutorEnv::builder()
            .write(&block_header)
            .unwrap()
            .write(&chain_work1)
            .unwrap()
            .build()
            .unwrap();

        // Obtain the default prover.
        let prover = default_prover();

        // Produce a receipt by proving the specified ELF binary.
        let receipt = prover.prove_elf(env, GUEST_ELF).unwrap();

        let (output_block_hash, chain_work): ([u8; 32], [u8; 32]) = receipt.journal.decode().unwrap();

        println!("Output: {}", hex::encode(output_block_hash));
        println!("Chain Work: {}", hex::encode(chain_work));

        // assert_eq!(
        //     hex::encode(chain_work),
        //     rpc_json_data[1]["chainwork"].as_str().unwrap()
        // );

        // Optional: Verify receipt to confirm that recipients will also be able to
        // verify your receipt
        receipt.verify(GUEST_ID).unwrap();
    }

    
}
